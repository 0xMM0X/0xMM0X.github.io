<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Black Hat Finals: Digital Forensics Challenge – Day 1 | MMOX Blog</title>
<meta name=keywords content="BTHMEA,Writeups,Digital Forensics,Memory Dump,Windows,PCAP,ReverseEngineering"><meta name=description content="This write-up presents a deep dive into the Black Hat Finals – Day 1 Forensics challenges, focusing exclusively on forensic analysis. The challenges required end-to-end investigation across network traffic analysis, memory forensics, malware reverse engineering, and cryptographic payload decryption."><meta name=author content="MMOX "><link rel=canonical href=https://mmox.me/posts/blackhatema-forensics/day1/><meta name=google-site-verification content="G-PK6NYWT73S"><meta name=msvalidate.01 content="DBD2C24F1154E160699876B8EB3374F0"><link crossorigin=anonymous href=/assets/css/stylesheet.5d45b8bd1a3cf526e72959d51f1bdc688d8e97fa0df2a697a93df6bdc746feb4.css integrity="sha256-XUW4vRo89SbnKVnVHxvcaI2Ol/oN8qaXqT32vcdG/rQ=" rel="preload stylesheet" as=style><noscript><link crossorigin=anonymous href=/css/includes/noscript.30127fa68e36d08f5dd7f9d4e717dac42e729b844672afd0fbcacb0d9e508595.css integrity="sha256-MBJ/po420I9d1/nU5xfaxC5ym4RGcq/Q+8rLDZ5QhZU=" rel="preload stylesheet" as=style></noscript><link rel=icon href=https://mmox.me/img/Favicon.webp><link rel=icon type=image/png sizes=16x16 href=https://mmox.me/img/Favicon.webp><link rel=icon type=image/png sizes=32x32 href=https://mmox.me/img/Favicon.webp><link rel=apple-touch-icon href=https://mmox.me/img/Favicon.webp><link rel=mask-icon href=https://mmox.me/img/Favicon.webp><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mmox.me/posts/blackhatema-forensics/day1/><script async src="https://www.googletagmanager.com/gtag/js?id=G-PK6NYWT73S"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PK6NYWT73S")}</script><meta property="og:title" content="Black Hat Finals: Digital Forensics Challenge – Day 1"><meta property="og:description" content="This write-up presents a deep dive into the Black Hat Finals – Day 1 Forensics challenges, focusing exclusively on forensic analysis. The challenges required end-to-end investigation across network traffic analysis, memory forensics, malware reverse engineering, and cryptographic payload decryption."><meta property="og:type" content="article"><meta property="og:url" content="https://mmox.me/posts/blackhatema-forensics/day1/"><meta property="og:image" content="https://mmox.me/img/profile.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-14T00:00:00+00:00"><meta property="og:site_name" content="MMOX"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://mmox.me/img/profile.png"><meta name=twitter:title content="Black Hat Finals: Digital Forensics Challenge – Day 1"><meta name=twitter:description content="This write-up presents a deep dive into the Black Hat Finals – Day 1 Forensics challenges, focusing exclusively on forensic analysis. The challenges required end-to-end investigation across network traffic analysis, memory forensics, malware reverse engineering, and cryptographic payload decryption."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mmox.me/posts/"},{"@type":"ListItem","position":2,"name":"Black Hat Finals: Digital Forensics Challenge – Day 1","item":"https://mmox.me/posts/blackhatema-forensics/day1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Black Hat Finals: Digital Forensics Challenge – Day 1","name":"Black Hat Finals: Digital Forensics Challenge – Day 1","description":"This write-up presents a deep dive into the Black Hat Finals – Day 1 Forensics challenges, focusing exclusively on forensic analysis. The challenges required end-to-end investigation across network traffic analysis, memory forensics, malware reverse engineering, and cryptographic payload decryption.","keywords":["BTHMEA","Writeups","Digital Forensics","Memory Dump","Windows","PCAP","ReverseEngineering"],"articleBody":" There was no level for each challenge so I am going to rate them as I found them\nDay1 InfectedWires Details Description: During a routine compromise assessment, a network capture was collected for analysis. As part of the assessment team, your task is to examine the PCAP and determine if signs of compromise exist.\nLevel: Easy\nChallenge Link: Download Challenge\nPassword: NLkEqTsGsYVbijpG97ec\nWriteup The investigation began with the review of a 1.27 GB packet capture file containing more than 2 million network packets collected over a 24-hour period. The objective was to identify internal network assets and understand normal communication patterns within the corporate environment.\nmy device started dying halfway through the analysis during the CTF Due to the challenges size.\nLeveraging Wireshark's Statistics → Conversations feature, the most active internal hosts were analyzed to understand normal network behavior:\nThe network was very chatty, with a large amount of TCP traffic flying around. After digging into the TCP conversation statistics, the main characters on the network quickly revealed themselves:\n10.3.10.11 was busy on port 8080, clearly acting as the web application server. 10.3.30.158 spent most of its time talking on port 1433, giving away its role as a SQL Server. 10.3.30.155 generated a ton of traffic on port 445, making it obvious this machine was the file server. 10.3.30.63 was chatting over LDAP (389) and Kerberos (88), which is a dead giveaway for the domain controller. 10.3.50.28 reached out to external IPs over HTTPS, behaving exactly like a normal user workstation. The web application server (10.3.10.11:8080) exhibited the most varied connection patterns, establishing it as the primary focus of investigation.\nTo focus on the interesting stuff, HTTP traffic was filtered down to the application server using the following filter, isolating only the conversations hitting 10.3.10.11 on port 8080:\nhttp and ip.dst == 10.3.10.11 and tcp.port == 8080 This filter quickly exposed several SharePoint-related endpoints, such as ToolPane.aspx and _layouts/15/start.aspx, confirming that the server was running SharePoint. With thousands of HTTP requests in play, manually reviewing each one was not practical, so a more strategic approach was required.\nTo cut through the noise, Wireshark → File → Export Objects → HTTP was used to extract all HTTP objects. These objects were then sorted by size, as exploit payloads are typically much larger than normal requests. Almost immediately, the ToolPane.aspx endpoint stood out as suspicious due to:\nOnce I saw it I remember a CVE I read about the same File using the CVE-2025-53771\nA closer look at the HTTP stream for the suspicious ToolPane.aspx request — noticeably larger than the other ToolPane requests — revealed several red flags:\nSpoofed Referrer: The request used /Signout.aspx as the referrer — a trick commonly seen with CVE-2025-53771, where authentication checks are bypassed by avoiding normal 401 responses. Attack Chain: This issue is often paired with CVE-2025-53770, forming a reliable path to remote code execution. Encoded Payload: The CompressedDataTable parameter contained heavily obfuscated data, layered as GZIP → Base64 → Base64, clearly designed to hide the real payload. Once the encoding pattern was clear, the payload was sent to CyberChef for decoding.\nProcessing the multi-layer encoding scheme using CyberChef shows:\nURL Decoding\nThe first decoding step revealed Base64-encoded, GZIP-compressed data hidden within the request. Decompression Base64 decoding was applied, followed by GZIP decompression Final Extraction\nDecoding the final Base64 layer revealed: The payload downloaded by the threat actor The flag, which turned out to be the name of their staging directory Final Flag BHFlagY{20347ad6eb0abad8369cd4ee8791cdff}\nMemBase Details Description: Our SIEM detected suspicious activity originating from the NT AUTHORITY/SYSTEM account, including the creation of a file named ngrok.yml. A memory dump of the affected system has been collected for your analysis.\"\nLevel: Insane (Very Very Hard)\nChallenge Link: Download Challenge\nPassword: zDLRQGogLxNX7HagpTw2\nWriteup The investigation kicked off with memory analysis using Volatility 3. The first stop was the malfind plugin. While it produced a large number of hits, most of them turned out to be false positives, with no clear signs of injected or malicious code at this stage.\nShifting focus, process enumeration was performed using pslist and psscan to map running processes and uncover suspicious parent–child relationships. This is where things started to get interesting with the help of the AI i gaved it all the processes and told him to find all the hidden processes.\nTwo processes immediately stood out:\nsqlagent.exe (PID 4940) running under sqlservr.exe, the legitimate Microsoft SQL Server service process conhost.exe (PID 8616) appearing alongside the SQL-related activity Before jumping into full reverse engineering, a quick triage was performed using the strings utility on both executables. This step did not reveal anything useful, suggesting the binaries were either packed, encrypted, or intentionally stripped of obvious indicators.\nNext, the windows.vadinfo plugin in Volatility was used to hunt for classic code-injection signs, specifically memory regions marked with PAGE_READWRITE_EXECUTE. This check came back clean for both processes, indicating no obvious injected executable memory regions at this stage.\nWith dynamic clues exhausted, the focus shifted to static reverse engineering, starting with sqlagent.exe. Disassembly in IDA Pro showed that the binary acts as a reflective PE loader, designed to load encrypted executables directly into memory. The loader allocates memory using VirtualAlloc with MEM_COMMIT | MEM_RESERVE (0x3000u) and initial PAGE_READWRITE permissions (4u), a common technique used to stage payloads before changing memory permissions and executing them.\nAfter allocating memory, the loader copies the PE headers and sections into the newly created memory region. It then iterates over each section and checks its characteristics flags, adjusting memory permissions on the fly using VirtualProtect.\nWhen a section is marked as readable, writable, and executable (0x20000000 | 0x40000000 | 0x80000000), the loader upgrades the memory protection to PAGE_EXECUTE_READWRITE (0x40).\nIn the disassembled code, this behavior is easy to spot: when all three section flags are present, the logic sets v36 = 64, which directly maps to PAGE_EXECUTE_READWRITE (0x40 in hex, 64 in decimal).\nThis reveals a classic two-stage memory allocation trick:\nMemory is first allocated as read-write (RW). Permissions are later upgraded to read-write-execute (RWX) only when needed. This approach helps the malware stay under the radar, as some security tools specifically watch for memory regions that are executable at allocation time. As a result, the memory initially appeared harmless with only PAGE_READWRITE permissions.\nAdditionally, the analysis revealed that the loader accepts two command-line arguments (parameters a2 and a3) and stores them as environment variables. These values are written to:\nSQLSVC_PATH SQLSVC_TARGET This behavior suggests the loader relies on externally supplied runtime configuration, likely to control payload location and execution targets during later stages.\nJumping back into memory analysis, the vadinfo plugin was run again against sqlagent.exe. This time, the focus was on memory regions marked as PAGE_READWRITE, since any injected payload might still be lurking there before having its permissions upgraded. The goal was simple: hunt for anything that looked writable and suspicious before it tried to become executable.\nStatic analysis of the injected executable in IDA Pro revealed its next move in the attack chain.\nThe code begins by enumerating all running processes using CreateToolhelp32Snapshot combined with Process32NextW. During this sweep, it looks for a specific process name pulled directly from the SQLSVC_TARGET environment variable.\nOnce the target process is found, its process ID is captured and stored in th32ProcessID.\nWith the target identified, the malware attempts to open the process using OpenProcess with PROCESS_ALL_ACCESS (0x1FFFFF) permissions — essentially asking for the keys to the kingdom. The resulting handle is stored in the variable v33, which is later assigned to a variable named Value for further use.\nAfter obtaining a handle to the target process, the malware takes things a step further by abusing parent process spoofing.\nThe code calls UpdateProcThreadAttribute with the attribute value 0x20000, which maps to PROC_THREAD_ATTRIBUTE_PARENT_PROCESS. By supplying \u0026Value (the handle to the target process obtained earlier), the malware tells Windows to treat that process as the parent of the next process it creates.\nWith the parent process attribute set, the malware then spawns a new process using CreateProcessA, building the command line from the CommandLine variable. As a result, the newly created process appears to be a legitimate child of the targeted process, helping it blend in and evade basic process-tree inspection.\nIn short:\nfake parent → legit-looking process tree → stealth achieved\nDigging deeper into the CommandLine variable showed that it is assembled inside the function sub_2674CB11870, which behaves similarly to sprintf_s. This function simply stitches together two values, v55 and v34, to form the final command line used when spawning the new process.\nTracing v55 back to its source revealed that it holds the value of the SQLSVC_PATH environment variable — the same variable that was previously set by sqlagent.exe. This confirms that the injected executable is reusing configuration data planted earlier in the attack chain, neatly tying the stages together.\nFor the second part of the command line (v34), the code calls the function sub_2674B11010, which turns out to be a simple XOR decryption routine. This function decrypts an embedded value and stores the result in a variable named aProcessorArchi, which is then assigned to v34.\nIn short: one part of the command line comes from an environment variable (SQLSVC_PATH), and the other is quietly XOR-decrypted at runtime — a classic move to keep juicy strings out of plain sight.\nThe decrypted value resolves to the PROCESS_ARCHITECTURE string, which is a standard Windows environment variable. This variable specifies the system’s processor architecture, such as x86, AMD64, IA64, or ARM64.\nBased on this behavior, it can be concluded that the newly spawned payload receives both the SQLSVC_PATH value (stored in v55) and the system’s PROCESSOR_ARCHITECTURE value (stored in v34) as command-line arguments. To further blend in with normal system activity, the process is launched with winlogon.exe spoofed as its parent process, helping the malware hide in plain sight.\nReviewing the process handles opened by sqlagent.exe with PROCESS_ALL_ACCESS (0x1FFFFF) permissions revealed two notable targets:\nconhost.exe (PID 8616) winlogon.exe (PID 576) By correlating these findings with the output from the pstree plugin, it became clear that winlogon.exe was the process to which the threat actor first obtained a handle. Since winlogon.exe typically runs with SYSTEM privileges, this handle was then abused to spoof the parent process of conhost.exe, which served as the attacker’s payload.\nAs a result, conhost.exe was spawned with winlogon.exe as its parent, effectively inheriting SYSTEM-level privileges. This behavior confirms a successful privilege escalation via parent process spoofing, leveraging CVE-2024-30088, a TOCTOU-based kernel privilege escalation vulnerability.\nStatic Analysis of conhost.exe: Analyzing the main function, the program expects exactly one command-line argument (argv[1]), which from previous analysis we know is “PROCESS_ARCHITECTURE”.\nCode analysis showed that this executable is also a reflective PE loader, very similar to sqlagent.exe, sharing most of the same logic with a few notable differences.\nThe loader calls the function sub_7FF7E1311470, passing the command-line argument directly to it. Disassembly of this function revealed that it implements AES-256-CBC decryption.\nFurther analysis of sub_7FF7E1311470 confirmed its role as an AES-256-CBC decryption routine. The function retrieves the value of the PROCESS_ARCHITECTURE environment variable, which had already been supplied as the argument a1. This value appears as lpName, with its contents stored in the Buffer variable.\nTo recover the PROCESS_ARCHITECTURE value, Volatility’s envars plugin was used. However, the exact architecture value could not be identified from the environment variables.\nInstead of storing the AES key directly, the malware hashes the environment variable value using SHA-256 to derive a 256-bit encryption key. This design ensures the real encryption key never exists in plaintext within the binary.\nThe encrypted payload is embedded directly in memory at offset 0x7FF7E1327AD0 and has a total size of 238,608 bytes.\nThe first 16 bytes located at offset 0x7FF7E1327AC0 serve as the hardcoded Initialization Vector (IV) for AES-256-CBC mode. This value corresponds to xmmword_7FF7E1327AC0, observed earlier during analysis.\nAfter decryption, the function validates success by checking for the PE MZ header (0x4D5A). Once confirmed, the decrypted payload is returned and reflectively loaded into memory.\nTo extract both the encrypted payload and the IV for offline decryption, IDA Pro’s Python scripting interface was used.\nExtracting the IV:\niv_data = ida_bytes.get_bytes(0x7FF7E1327AC0, 16) print(\" \".join(\"%02X\" % b for b in iv_data)) # Save IV to file with open(\"D:\\\\BTH-Finals\\\\iv.bin\", \"wb\") as f: f.write(iv_data) print(\"Saved IV to iv.bin\") Extracting Encrypted Payload\n# Starting address of encrypted payload start_addr = 0x7FF7E1327AD0 # Size of encrypted payload size = 238608 print(\"Extracting %d bytes from address 0x%X\" % (size, start_addr)) # Read the bytes encrypted_data = ida_bytes.get_bytes(start_addr, size) if encrypted_data is None: print(\"ERROR: Could not read data!\") else: # Save to file output_file = \"D:\\\\BTH-Finals\\\\encrypted_payload.bin\" try: with open(output_file, \"wb\") as f: f.write(encrypted_data) print(\"SUCCESS! Saved %d bytes to %s\" % (len(encrypted_data), output_file)) except Exception as e: print(\"ERROR writing file: %s\" % str(e)) With the IV, encrypted blob, and key-derivation logic identified, I wrote a small decryption script to: - decrypt the payload - confirm success by checking the MZ header - finally dump the decrypted executable to disk.\nfrom Crypto.Cipher import AES from Crypto.Hash import SHA256 import sys from pathlib import Path # --- Config --- ENCRYPTED_FILE = \"encrypted_payload.bin\" IV_FILE = \"iv.bin\" OUT_DIR = Path(\"bruteforce_out\") OUT_DIR.mkdir(exist_ok=True) # Common values you might see in PROCESSOR_ARCHITECTURE CANDIDATES = [ \"AMD64\", \"x86\", \"ARM64\", \"IA64\", \"ARM\", \"EM64T\", # sometimes seen historically \"x64\", # not standard, but worth trying \"AARCH64\", # occasionally used in tooling ] def read_file(path: str) -\u003e bytes: p = Path(path) if not p.exists(): print(f\"[!] Missing file: {p.resolve()}\") sys.exit(1) return p.read_bytes() def try_decrypt(env_value: str, encrypted: bytes, iv: bytes) -\u003e bytes: key = SHA256.new(env_value.encode(\"utf-8\")).digest() # 32 bytes =\u003e AES-256 key cipher = AES.new(key, AES.MODE_CBC, iv) dec = cipher.decrypt(encrypted) # Try PKCS7 unpadding (best effort) if len(dec) \u003e 0: pad = dec[-1] if 1 \u003c= pad \u003c= 16 and dec[-pad:] == bytes([pad]) * pad: dec = dec[:-pad] return dec def is_pe_mz(blob: bytes) -\u003e bool: return len(blob) \u003e= 2 and blob[:2] == b\"MZ\" def main(): print(\"[1] Reading encrypted payload...\") encrypted_data = read_file(ENCRYPTED_FILE) print(f\" Encrypted size: {len(encrypted_data)} bytes\") print(\"[2] Reading IV...\") iv = read_file(IV_FILE) if len(iv) != 16: print(f\"[!] IV length is {len(iv)} bytes (expected 16).\") sys.exit(1) print(f\" IV: {iv.hex()}\") print(\"[3] Brute forcing common PROCESSOR_ARCHITECTURE values...\\n\") hits = 0 for cand in CANDIDATES: decrypted = try_decrypt(cand, encrypted_data, iv) if is_pe_mz(decrypted): hits += 1 out_path = OUT_DIR / f\"decrypted_{cand}.exe\" out_path.write_bytes(decrypted) key_hex = SHA256.new(cand.encode(\"utf-8\")).digest().hex() print(f\"[+] HIT: {cand}\") print(f\" Key(SHA-256): {key_hex}\") print(f\" Saved: {out_path} ({len(decrypted)} bytes)\\n\") # If you only want the first valid result, uncomment this: # break else: print(f\"[-] {cand}: not a PE (first bytes: {decrypted[:8].hex()})\") if hits == 0: print(\"\\n[!] No valid PE hits found.\") print(\" Possible issues:\") print(\" - The architecture value is different/unexpected\") print(\" - IV/encrypted blob offsets are wrong\") print(\" - Different key derivation or mode/padding\") # Save last attempt for inspection (optional) (OUT_DIR / \"last_decrypted_raw.bin\").write_bytes(decrypted) print(f\" Saved last attempt to: {OUT_DIR / 'last_decrypted_raw.bin'}\") else: print(f\"\\n[SUCCESS] Found {hits} valid PE candidate(s). Check: {OUT_DIR.resolve()}\") if __name__ == \"__main__\": main() Analysis of the decrypted executable was performed to understand its behavior.\nThe executable has two main functions:\nCreating a persistent user account and adding it to both the Administrators and Remote Desktop Users groups. Decrypting an ngrok.yml file and writing a flag.txt file to the same directory. For the purpose of this challenge, the focus was placed solely on the decryption logic, while the persistence functionality was ignored.\nFurther inspection of the function sub_140004430 shows that it constructs two file paths, Src and v4, by:\nUsing string operations to build paths under C:\\Users\\Public\\Documents Referencing the ngrok subdirectory Defining ngrok.yml as the input file and flag.txt as the output file This function acts as a wrapper around the main decryption routine, sub_140003C50. The wrapper passes two arguments to the function:\nSrc: the source (input) file path v4: the destination (output) file path A deeper look at sub_140003C50 shows that it is the core decryption logic. It accepts two parameters:\na1: input file path (Documents\\ngrok\\ngrok.yml) a2: output file path (Documents\\ngrok\\flag.txt) The function reads the contents of ngrok.yml into memory, where the data is identified as being encrypted using AES-256-CBC.\nDuring analysis, the address \u0026unk_140032928 was observed being passed directly into the EVP_DecryptInit_ex function. This indicates:\nAddress 0x140032928 holds the AES-256 key (32 bytes) Variable v52 contains the Initialization Vector (IV) (16 bytes) The decryption process follows the standard OpenSSL EVP workflow:\nEVP_DecryptUpdate handles the bulk of the encrypted data EVP_DecryptFinal_ex completes the decryption and removes PKCS#7 padding v27 stores the final decrypted plaintext v29 holds the total size of the decrypted data Once decryption completes, sub_140006010 writes the decrypted contents from buffer v27 (length v29) to the output file flag.txt.\nThe IV is referenced through v52. By inspecting nearby XMM register loads, the IV can be recovered as follows:\n# IV may be at xmmword_140032A50 (referenced in main) iv_addr = 0x140032A50 iv_data = ida_bytes.get_bytes(iv_addr, 16) print(\"IV (16 bytes):\") print(\" \".join(\"%02X\" % b for b in iv_data)) # Save IV to file with open(\"D:\\\\BTH-Finals\\\\aes_iv.bin\", \"wb\") as f: f.write(iv_data) print(\"Saved IV to aes_iv.bin\") For extracting the AES-256 Key (32 bytes): ```python import ida_bytes # Key is at address 0x140032928 key_addr = 0x140032928 key_data = ida_bytes.get_bytes(key_addr, 32) print(\"=\"*60) print(\"AES-256 KEY (32 bytes):\") print(\" \".join(\"%02X\" % b for b in key_data)) print(\"=\"*60) # Save to file with open(\"D:\\\\BTH-Finals\\\\aes_key.bin\", \"wb\") as f: f.write(key_data) print(\"Saved key to aes_key.bin\") Since ngrok.yml was already present on disk, the next step was simply to grab it. Using R-Studio on the memory image, I navigated to the file system and successfully recovered the file from: C:\\Users\\Public\\Documents\\ngrok\\ngrok.yml With the encrypted config now in hand, it was ready for offline decryption and further analysis.\nUtilizing the following script to decrypt the ngrok.yml and get the final flag.txt:\nfrom Crypto.Cipher import AES import sys # -------------------------------------------------- # Step 1: Read encrypted ngrok.yml # -------------------------------------------------- print(\"[1] Loading encrypted ngrok.yml...\") with open(\"ngrok.yml\", \"rb\") as f: encrypted_data = f.read() print(f\" Encrypted size: {len(encrypted_data)} bytes\") # -------------------------------------------------- # Step 2: Load AES-256 key # -------------------------------------------------- print(\"[2] Loading AES-256 key...\") with open(\"aes_key.bin\", \"rb\") as f: key = f.read() print(f\" Key length: {len(key)} bytes\") # -------------------------------------------------- # Step 3: Load IV # -------------------------------------------------- print(\"[3] Loading IV...\") with open(\"aes_iv.bin\", \"rb\") as f: iv = f.read() print(f\" IV length: {len(iv)} bytes\") # -------------------------------------------------- # Sanity checks # -------------------------------------------------- if len(key) != 32: print(f\"[!] Invalid key size: {len(key)} bytes (expected 32)\") sys.exit(1) if len(iv) != 16: print(f\"[!] Invalid IV size: {len(iv)} bytes (expected 16)\") sys.exit(1) # -------------------------------------------------- # Step 4: AES-256-CBC Decryption # -------------------------------------------------- print(\"[4] Decrypting using AES-256-CBC...\") cipher = AES.new(key, AES.MODE_CBC, iv) decrypted_data = cipher.decrypt(encrypted_data) # -------------------------------------------------- # Step 5: Remove PKCS#7 padding # -------------------------------------------------- padding_len = decrypted_data[-1] if 1 \u003c= padding_len \u003c= 16: decrypted_data = decrypted_data[:-padding_len] print(f\" Removed {padding_len} bytes of PKCS#7 padding\") else: print(\" Warning: Padding looks suspicious\") # -------------------------------------------------- # Step 6: Validate \u0026 save output # -------------------------------------------------- print(\"[5] Validating decrypted content...\") try: plaintext = decrypted_data.decode(\"utf-8\") print(\" ✓ Valid UTF-8 text detected\") with open(\"flag.txt\", \"w\", encoding=\"utf-8\") as f: f.write(plaintext) print(\"\\n[SUCCESS] flag.txt successfully decrypted!\") print(\"\\nFlag content:\\n\") print(plaintext) except UnicodeDecodeError: print(\" ✗ Decrypted data is not UTF-8 text\") with open(\"flag.bin\", \"wb\") as f: f.write(decrypted_data) print(\" Saved raw output to flag.bin for further analysis\") The final flag was successfully extracted to flag.txt.\nFinal Flag BHFlagY{8498302a9b7096d6ee49fc6da62496a1}\n","wordCount":"3177","inLanguage":"en","datePublished":"2025-12-14T00:00:00Z","dateModified":"2025-12-14T00:00:00Z","author":{"@type":"Person","name":"MMOX "},"mainEntityOfPage":{"@type":"WebPage","@id":"https://mmox.me/posts/blackhatema-forensics/day1/"},"publisher":{"@type":"Organization","name":"MMOX Blog","logo":{"@type":"ImageObject","url":"https://mmox.me/img/Favicon.webp"}}}</script></head><body id=top><script crossorigin=anonymous src=/assets/js/theme.b20f95bb4da41ef90a2610a557a7000b2649a3f47282ec571676da6fc0427200.js integrity="sha256-sg+Vu02kHvkKJhClV6cACyZJo/RyguxXFnbab8BCcgA="></script><header class=header><div id=progressBar></div><nav class=nav><div class=logo><a href=https://mmox.me/ accesskey=h title="MMOX (Alt + H)">MMOX</a>
<button type=button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><input name=hamburger-input id=hamburger-input type=checkbox aria-label="Navigation Menu">
<label id=hamburger-menu for=hamburger-input></label><div class=overlay></div><ul id=menu><li><a href=https://mmox.me/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://mmox.me/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://mmox.me/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://mmox.me/mylabs/ title=MyLabs><span>MyLabs</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://mmox.me/>Home</a>&nbsp;»&nbsp;<a href=https://mmox.me/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Black Hat Finals: Digital Forensics Challenge – Day 1</h1><div class=post-description>This write-up presents a deep dive into the Black Hat Finals – Day 1 Forensics challenges, focusing exclusively on forensic analysis. The challenges required end-to-end investigation across network traffic analysis, memory forensics, malware reverse engineering, and cryptographic payload decryption.</div><div class=post-meta><span title='2025-12-14 00:00:00 +0000 UTC'>December 14, 2025</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;MMOX</div><div class=post-meta></div></header><div class="toc side"><details id=toc><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#day1 aria-label=Day1>Day1</a><ul><li><a href=#infectedwires aria-label=InfectedWires>InfectedWires</a><ul><li><a href=#details aria-label=Details>Details</a></li><li><a href=#writeup aria-label=Writeup>Writeup</a></li><li><a href=#final-flag aria-label="Final Flag">Final Flag</a></li></ul></li><li><a href=#membase aria-label=MemBase>MemBase</a><ul><li><a href=#details-1 aria-label=Details>Details</a></li><li><a href=#writeup-1 aria-label=Writeup>Writeup</a></li><li><a href=#final-flag-1 aria-label="Final Flag">Final Flag</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><p><img loading=lazy src=/BTH/Day1/logo.png alt=logo></p><blockquote><p>There was no level for each challenge so I am going to rate them as I found them</p></blockquote><h1 id=day1>Day1<a hidden class=anchor aria-hidden=true href=#day1>#</a></h1><h2 id=infectedwires>InfectedWires<a hidden class=anchor aria-hidden=true href=#infectedwires>#</a></h2><h3 id=details>Details<a hidden class=anchor aria-hidden=true href=#details>#</a></h3><p><strong>Description:</strong> During a routine compromise assessment, a network capture was collected for analysis. As part of the assessment team, your task is to examine the PCAP and determine if signs of compromise exist.</p><p><strong>Level:</strong> Easy</p><p><strong>Challenge Link:</strong> <a href="https://drive.google.com/file/d/1p06kIEYjchEzqztfRj0-B8rdSOX0ZO4p/view?usp=sharing">Download Challenge</a></p><p><strong>Password:</strong> <code>NLkEqTsGsYVbijpG97ec</code></p><h3 id=writeup>Writeup<a hidden class=anchor aria-hidden=true href=#writeup>#</a></h3><p>The investigation began with the review of a 1.27 GB packet capture file containing more than 2 million network packets collected over a 24-hour period. The objective was to identify internal network assets and understand normal communication patterns within the corporate environment.</p><blockquote><p>my device started dying halfway through the analysis during the CTF Due to the challenges size.</p></blockquote><p>Leveraging Wireshark's Statistics → Conversations feature, the most active internal hosts were analyzed to understand normal network behavior:</p><p><img loading=lazy src=/BTH/Day1/infectedwires_1.png alt>
The network was very chatty, with a large amount of TCP traffic flying around. After digging into the TCP conversation statistics, the main characters on the network quickly revealed themselves:</p><ul><li>10.3.10.11 was busy on port 8080, clearly acting as the web application server.</li><li>10.3.30.158 spent most of its time talking on port 1433, giving away its role as a SQL Server.</li><li>10.3.30.155 generated a ton of traffic on port 445, making it obvious this machine was the file server.</li><li>10.3.30.63 was chatting over LDAP (389) and Kerberos (88), which is a dead giveaway for the domain controller.</li><li>10.3.50.28 reached out to external IPs over HTTPS, behaving exactly like a normal user workstation.</li></ul><p><strong>The web application server (10.3.10.11:8080) exhibited the most varied connection patterns, establishing it as the primary focus of investigation.</strong></p><p>To focus on the interesting stuff, HTTP traffic was filtered down to the application server using the following filter, isolating only the conversations hitting 10.3.10.11 on port 8080:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nginx data-lang=nginx><span class=line><span class=cl><span class=k>http</span> <span class=s>and</span> <span class=s>ip.dst</span> <span class=p>==</span> <span class=mi>10</span><span class=s>.3.10.11</span> <span class=s>and</span> <span class=s>tcp.port</span> <span class=p>==</span> <span class=mi>8080</span>
</span></span></code></pre></div><p><img loading=lazy src=/BTH/Day1/infectedwires_2.png alt></p><p>This filter quickly exposed several SharePoint-related endpoints, such as <code>ToolPane.aspx</code> and <code>_layouts/15/start.aspx</code>, confirming that the server was running <strong>SharePoint</strong>. With thousands of HTTP requests in play, manually reviewing each one was not practical, so a more strategic approach was required.</p><p>To cut through the noise, <strong>Wireshark → File → Export Objects → HTTP</strong> was used to extract all HTTP objects. These objects were then sorted by size, as exploit payloads are typically much larger than normal requests. Almost immediately, the <code>ToolPane.aspx</code> endpoint stood out as suspicious due to:</p><p><img loading=lazy src=/BTH/Day1/infectedwires_3.png alt></p><p>Once I saw it I remember a CVE I read about the same File using the <a href=https://www.bleepingcomputer.com/news/microsoft/microsoft-sharepoint-zero-day-exploited-in-rce-attacks-no-patch-available/>CVE-2025-53771</a></p><p>A closer look at the HTTP stream for the suspicious <code>ToolPane.aspx</code> request — noticeably larger than the other ToolPane requests — revealed several red flags:</p><p><img loading=lazy src=/BTH/Day1/infectedwires_4.png alt></p><ul><li><strong>Spoofed Referrer</strong>: The request used <code>/Signout.aspx</code> as the referrer — a trick commonly seen with <strong>CVE-2025-53771</strong>, where authentication checks are bypassed by avoiding normal 401 responses.</li><li><strong>Attack Chain</strong>: This issue is often paired with <strong>CVE-2025-53770</strong>, forming a reliable path to remote code execution.</li><li><strong>Encoded Payload</strong>: The <code>CompressedDataTable</code> parameter contained heavily obfuscated data, layered as <strong>GZIP → Base64 → Base64</strong>, clearly designed to hide the real payload.</li></ul><p>Once the encoding pattern was clear, the payload was sent to <strong>CyberChef</strong> for decoding.</p><p>Processing the multi-layer encoding scheme using CyberChef shows:</p><ol><li><strong>URL Decoding</strong><br>The first decoding step revealed Base64-encoded, GZIP-compressed data hidden within the request.</li></ol><p><img loading=lazy src=/BTH/Day1/infectedwires_5.png alt></p><ol start=2><li><strong>Decompression</strong>
Base64 decoding was applied, followed by GZIP decompression</li></ol><p><img loading=lazy src=/BTH/Day1/infectedwires_6.png alt></p><ol start=3><li><strong>Final Extraction</strong><br>Decoding the final Base64 layer revealed:<ul><li>The payload downloaded by the threat actor</li><li>The flag, which turned out to be the name of their staging directory</li></ul></li></ol><p><img loading=lazy src=/BTH/Day1/infectedwires_7.png alt></p><h3 id=final-flag>Final Flag<a hidden class=anchor aria-hidden=true href=#final-flag>#</a></h3><blockquote><p>BHFlagY{20347ad6eb0abad8369cd4ee8791cdff}</p></blockquote><hr><h2 id=membase>MemBase<a hidden class=anchor aria-hidden=true href=#membase>#</a></h2><h3 id=details-1>Details<a hidden class=anchor aria-hidden=true href=#details-1>#</a></h3><p><strong>Description:</strong> Our SIEM detected suspicious activity originating from the NT AUTHORITY/SYSTEM account, including the creation of a file named ngrok.yml. A memory dump of the affected system has been collected for your analysis."</p><p><strong>Level:</strong> Insane (Very Very Hard)</p><p><strong>Challenge Link:</strong> <a href="https://drive.google.com/file/d/1_atBFT_sypdsIgPsmmCJd74ave7PzZ0f/view?usp=sharing">Download Challenge</a></p><p><strong>Password:</strong> <code>zDLRQGogLxNX7HagpTw2</code></p><h3 id=writeup-1>Writeup<a hidden class=anchor aria-hidden=true href=#writeup-1>#</a></h3><p>The investigation kicked off with <strong>memory analysis using Volatility 3</strong>. The first stop was the <code>malfind</code> plugin. While it produced a large number of hits, most of them turned out to be false positives, with no clear signs of injected or malicious code at this stage.</p><p>Shifting focus, process enumeration was performed using <code>pslist</code> and <code>psscan</code> to map running processes and uncover suspicious parent–child relationships. This is where things started to get interesting with the help of the AI i gaved it all the processes and told him to find all the hidden processes.</p><p>Two processes immediately stood out:</p><ul><li><strong><code>sqlagent.exe</code> (PID 4940)</strong> running under <strong><code>sqlservr.exe</code></strong>, the legitimate Microsoft SQL Server service process</li><li><strong><code>conhost.exe</code> (PID 8616)</strong> appearing alongside the SQL-related activity</li></ul><p><img loading=lazy src=/BTH/Day1/membase_1.png alt></p><p>Before jumping into full reverse engineering, a quick triage was performed using the <code>strings</code> utility on both executables. This step did not reveal anything useful, suggesting the binaries were either packed, encrypted, or intentionally stripped of obvious indicators.</p><p>Next, the <code>windows.vadinfo</code> plugin in Volatility was used to hunt for classic code-injection signs, specifically memory regions marked with <code>PAGE_READWRITE_EXECUTE</code>. This check came back clean for both processes, indicating no obvious injected executable memory regions at this stage.</p><p>With dynamic clues exhausted, the focus shifted to static reverse engineering, starting with <code>sqlagent.exe</code>. Disassembly in <strong>IDA Pro</strong> showed that the binary acts as a <strong>reflective PE loader</strong>, designed to load encrypted executables directly into memory. The loader allocates memory using <code>VirtualAlloc</code> with <code>MEM_COMMIT | MEM_RESERVE</code> (<code>0x3000u</code>) and initial <code>PAGE_READWRITE</code> permissions (<code>4u</code>), a common technique used to stage payloads before changing memory permissions and executing them.</p><p><img loading=lazy src=/BTH/Day1/membase_2.png alt></p><p>After allocating memory, the loader copies the PE headers and sections into the newly created memory region. It then iterates over each section and checks its <strong>characteristics flags</strong>, adjusting memory permissions on the fly using <code>VirtualProtect</code>.</p><p>When a section is marked as <strong>readable, writable, and executable</strong> (<code>0x20000000 | 0x40000000 | 0x80000000</code>), the loader upgrades the memory protection to <code>PAGE_EXECUTE_READWRITE</code> (<code>0x40</code>).</p><p>In the disassembled code, this behavior is easy to spot: when all three section flags are present, the logic sets <code>v36 = 64</code>, which directly maps to <code>PAGE_EXECUTE_READWRITE</code> (<code>0x40</code> in hex, <code>64</code> in decimal).</p><p>This reveals a classic <strong>two-stage memory allocation trick</strong>:</p><ol><li>Memory is first allocated as <strong>read-write (RW)</strong>.</li><li>Permissions are later upgraded to <strong>read-write-execute (RWX)</strong> only when needed.</li></ol><p>This approach helps the malware stay under the radar, as some security tools specifically watch for memory regions that are executable at allocation time. As a result, the memory initially appeared harmless with only <code>PAGE_READWRITE</code> permissions.</p><p><img loading=lazy src=/BTH/Day1/membase_3.png alt></p><p>Additionally, the analysis revealed that the loader accepts two command-line arguments (parameters <code>a2</code> and <code>a3</code>) and stores them as environment variables. These values are written to:</p><ul><li><code>SQLSVC_PATH</code></li><li><code>SQLSVC_TARGET</code></li></ul><p>This behavior suggests the loader relies on externally supplied runtime configuration, likely to control payload location and execution targets during later stages.</p><p><img loading=lazy src=/BTH/Day1/membase_4.png alt></p><p><img loading=lazy src=/BTH/Day1/membase_5.png alt></p><p>Jumping back into memory analysis, the <code>vadinfo</code> plugin was run again against <code>sqlagent.exe</code>. This time, the focus was on memory regions marked as <code>PAGE_READWRITE</code>, since any injected payload might still be lurking there before having its permissions upgraded. The goal was simple: hunt for anything that looked writable <em>and</em> suspicious before it tried to become executable.</p><p><img loading=lazy src=/BTH/Day1/membase_6.png alt></p><p>Static analysis of the injected executable in <strong>IDA Pro</strong> revealed its next move in the attack chain.</p><p>The code begins by enumerating all running processes using <code>CreateToolhelp32Snapshot</code> combined with <code>Process32NextW</code>. During this sweep, it looks for a specific process name pulled directly from the <code>SQLSVC_TARGET</code> environment variable.</p><p>Once the target process is found, its process ID is captured and stored in <code>th32ProcessID</code>.</p><p>With the target identified, the malware attempts to open the process using <code>OpenProcess</code> with <strong>PROCESS_ALL_ACCESS</strong> (<code>0x1FFFFF</code>) permissions — essentially asking for the keys to the kingdom. The resulting handle is stored in the variable <code>v33</code>, which is later assigned to a variable named <code>Value</code> for further use.</p><p><img loading=lazy src=/BTH/Day1/membase_7.png alt></p><p>After obtaining a handle to the target process, the malware takes things a step further by abusing <strong>parent process spoofing</strong>.</p><p>The code calls <code>UpdateProcThreadAttribute</code> with the attribute value <code>0x20000</code>, which maps to <code>PROC_THREAD_ATTRIBUTE_PARENT_PROCESS</code>. By supplying <code>&amp;Value</code> (the handle to the target process obtained earlier), the malware tells Windows to treat that process as the <em>parent</em> of the next process it creates.</p><p>With the parent process attribute set, the malware then spawns a new process using <code>CreateProcessA</code>, building the command line from the <code>CommandLine</code> variable. As a result, the newly created process appears to be a legitimate child of the targeted process, helping it blend in and evade basic process-tree inspection.</p><p>In short:<br><strong>fake parent → legit-looking process tree → stealth achieved</strong></p><p><img loading=lazy src=/BTH/Day1/membase_8.png alt></p><p>Digging deeper into the <code>CommandLine</code> variable showed that it is assembled inside the function <code>sub_2674CB11870</code>, which behaves similarly to <code>sprintf_s</code>. This function simply stitches together two values, <code>v55</code> and <code>v34</code>, to form the final command line used when spawning the new process.</p><p>Tracing <code>v55</code> back to its source revealed that it holds the value of the <code>SQLSVC_PATH</code> environment variable — the same variable that was previously set by <code>sqlagent.exe</code>. This confirms that the injected executable is reusing configuration data planted earlier in the attack chain, neatly tying the stages together.</p><p><img loading=lazy src=/BTH/Day1/membase_9.png alt></p><p>For the second part of the command line (<code>v34</code>), the code calls the function <code>sub_2674B11010</code>, which turns out to be a simple <strong>XOR decryption routine</strong>. This function decrypts an embedded value and stores the result in a variable named <code>aProcessorArchi</code>, which is then assigned to <code>v34</code>.</p><p>In short: one part of the command line comes from an environment variable (<code>SQLSVC_PATH</code>), and the other is quietly XOR-decrypted at runtime — a classic move to keep juicy strings out of plain sight.</p><p><img loading=lazy src=/BTH/Day1/membase_10.png alt></p><p><img loading=lazy src=/BTH/Day1/membase_11.png alt></p><p>The decrypted value resolves to the <code>PROCESS_ARCHITECTURE</code> string, which is a standard Windows environment variable. This variable specifies the system’s processor architecture, such as <strong>x86</strong>, <strong>AMD64</strong>, <strong>IA64</strong>, or <strong>ARM64</strong>.</p><p><img loading=lazy src=/BTH/Day1/membase_12.png alt></p><p>Based on this behavior, it can be concluded that the newly spawned payload receives both the SQLSVC_PATH value (stored in v55) and the system’s PROCESSOR_ARCHITECTURE value (stored in v34) as command-line arguments. To further blend in with normal system activity, the process is launched with winlogon.exe spoofed as its parent process, helping the malware hide in plain sight.</p><p><img loading=lazy src=/BTH/Day1/membase_13.png alt></p><p>Reviewing the process handles opened by <code>sqlagent.exe</code> with <strong>PROCESS_ALL_ACCESS</strong> (<code>0x1FFFFF</code>) permissions revealed two notable targets:</p><ul><li><code>conhost.exe</code> (PID 8616)</li><li><code>winlogon.exe</code> (PID 576)</li></ul><p>By correlating these findings with the output from the <code>pstree</code> plugin, it became clear that <code>winlogon.exe</code> was the process to which the threat actor first obtained a handle. Since <code>winlogon.exe</code> typically runs with <strong>SYSTEM</strong> privileges, this handle was then abused to spoof the parent process of <code>conhost.exe</code>, which served as the attacker’s payload.</p><p>As a result, <code>conhost.exe</code> was spawned with <code>winlogon.exe</code> as its parent, effectively inheriting <strong>SYSTEM-level privileges</strong>. This behavior confirms a successful privilege escalation via <strong>parent process spoofing</strong>, leveraging <strong>CVE-2024-30088</strong>, a TOCTOU-based kernel privilege escalation vulnerability.</p><ol start=9><li>Static Analysis of <code>conhost.exe</code>:</li></ol><p>Analyzing the main function, the program expects exactly one command-line argument (<code>argv[1]</code>), which from previous analysis we know is &ldquo;PROCESS_ARCHITECTURE&rdquo;.</p><p><img loading=lazy src=/BTH/Day1/membase_14.png alt></p><p>Code analysis showed that this executable is also a <strong>reflective PE loader</strong>, very similar to <code>sqlagent.exe</code>, sharing most of the same logic with a few notable differences.</p><p>The loader calls the function <code>sub_7FF7E1311470</code>, passing the command-line argument directly to it. Disassembly of this function revealed that it implements <strong>AES-256-CBC decryption</strong>.</p><p><img loading=lazy src=/BTH/Day1/membase_15.png alt></p><p>Further analysis of <code>sub_7FF7E1311470</code> confirmed its role as an <strong>AES-256-CBC decryption routine</strong>. The function retrieves the value of the <code>PROCESS_ARCHITECTURE</code> environment variable, which had already been supplied as the argument <code>a1</code>. This value appears as <code>lpName</code>, with its contents stored in the <code>Buffer</code> variable.</p><p><img loading=lazy src=/BTH/Day1/membase_16.png alt></p><p>To recover the <code>PROCESS_ARCHITECTURE</code> value, Volatility’s <code>envars</code> plugin was used. However, the exact architecture value could not be identified from the environment variables.</p><p><img loading=lazy src=/BTH/Day1/membase_17.png alt></p><p>Instead of storing the AES key directly, the malware hashes the environment variable value using <strong>SHA-256</strong> to derive a 256-bit encryption key. This design ensures the real encryption key never exists in plaintext within the binary.</p><p><img loading=lazy src=/BTH/Day1/membase_18.png alt></p><p>The encrypted payload is embedded directly in memory at offset <code>0x7FF7E1327AD0</code> and has a total size of <strong>238,608 bytes</strong>.</p><p><img loading=lazy src=/BTH/Day1/membase_19.png alt></p><p>The first 16 bytes located at offset <code>0x7FF7E1327AC0</code> serve as the hardcoded <strong>Initialization Vector (IV)</strong> for AES-256-CBC mode. This value corresponds to <code>xmmword_7FF7E1327AC0</code>, observed earlier during analysis.</p><p><img loading=lazy src=/BTH/Day1/membase_20.png alt></p><p>After decryption, the function validates success by checking for the PE <code>MZ</code> header (<code>0x4D5A</code>). Once confirmed, the decrypted payload is returned and reflectively loaded into memory.</p><p><img loading=lazy src=/BTH/Day1/membase_21.png alt></p><p>To extract both the encrypted payload and the IV for offline decryption, IDA Pro’s Python scripting interface was used.</p><p>Extracting the IV:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>iv_data</span> <span class=o>=</span> <span class=n>ida_bytes</span><span class=o>.</span><span class=n>get_bytes</span><span class=p>(</span><span class=mh>0x7FF7E1327AC0</span><span class=p>,</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34; &#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%02X</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=n>b</span> <span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=n>iv_data</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Save IV to file</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;D:</span><span class=se>\\</span><span class=s2>BTH-Finals</span><span class=se>\\</span><span class=s2>iv.bin&#34;</span><span class=p>,</span> <span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>iv_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Saved IV to iv.bin&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>Extracting Encrypted Payload</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># Starting address of encrypted payload</span>
</span></span><span class=line><span class=cl><span class=n>start_addr</span> <span class=o>=</span> <span class=mh>0x7FF7E1327AD0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Size of encrypted payload</span>
</span></span><span class=line><span class=cl><span class=n>size</span> <span class=o>=</span> <span class=mi>238608</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Extracting </span><span class=si>%d</span><span class=s2> bytes from address 0x</span><span class=si>%X</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=p>(</span><span class=n>size</span><span class=p>,</span> <span class=n>start_addr</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Read the bytes</span>
</span></span><span class=line><span class=cl><span class=n>encrypted_data</span> <span class=o>=</span> <span class=n>ida_bytes</span><span class=o>.</span><span class=n>get_bytes</span><span class=p>(</span><span class=n>start_addr</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>encrypted_data</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;ERROR: Could not read data!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1># Save to file</span>
</span></span><span class=line><span class=cl>    <span class=n>output_file</span> <span class=o>=</span> <span class=s2>&#34;D:</span><span class=se>\\</span><span class=s2>BTH-Finals</span><span class=se>\\</span><span class=s2>encrypted_payload.bin&#34;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=n>output_file</span><span class=p>,</span> <span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>encrypted_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;SUCCESS! Saved </span><span class=si>%d</span><span class=s2> bytes to </span><span class=si>%s</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>encrypted_data</span><span class=p>),</span> <span class=n>output_file</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>except</span> <span class=ne>Exception</span> <span class=k>as</span> <span class=n>e</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;ERROR writing file: </span><span class=si>%s</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=nb>str</span><span class=p>(</span><span class=n>e</span><span class=p>))</span>
</span></span></code></pre></div><p>With the IV, encrypted blob, and key-derivation logic identified, I wrote a small decryption script to:
- decrypt the payload
- confirm success by checking the MZ header
- finally dump the decrypted executable to disk.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>Crypto.Cipher</span> <span class=kn>import</span> <span class=n>AES</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>Crypto.Hash</span> <span class=kn>import</span> <span class=n>SHA256</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --- Config ---</span>
</span></span><span class=line><span class=cl><span class=n>ENCRYPTED_FILE</span> <span class=o>=</span> <span class=s2>&#34;encrypted_payload.bin&#34;</span>
</span></span><span class=line><span class=cl><span class=n>IV_FILE</span> <span class=o>=</span> <span class=s2>&#34;iv.bin&#34;</span>
</span></span><span class=line><span class=cl><span class=n>OUT_DIR</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=s2>&#34;bruteforce_out&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>OUT_DIR</span><span class=o>.</span><span class=n>mkdir</span><span class=p>(</span><span class=n>exist_ok</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Common values you might see in PROCESSOR_ARCHITECTURE</span>
</span></span><span class=line><span class=cl><span class=n>CANDIDATES</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;AMD64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;x86&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;ARM64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;IA64&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;ARM&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;EM64T&#34;</span><span class=p>,</span>     <span class=c1># sometimes seen historically</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;x64&#34;</span><span class=p>,</span>       <span class=c1># not standard, but worth trying</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;AARCH64&#34;</span><span class=p>,</span>   <span class=c1># occasionally used in tooling</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>read_file</span><span class=p>(</span><span class=n>path</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bytes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=n>path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>p</span><span class=o>.</span><span class=n>exists</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[!] Missing file: </span><span class=si>{</span><span class=n>p</span><span class=o>.</span><span class=n>resolve</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=o>.</span><span class=n>read_bytes</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>try_decrypt</span><span class=p>(</span><span class=n>env_value</span><span class=p>:</span> <span class=nb>str</span><span class=p>,</span> <span class=n>encrypted</span><span class=p>:</span> <span class=nb>bytes</span><span class=p>,</span> <span class=n>iv</span><span class=p>:</span> <span class=nb>bytes</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bytes</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>key</span> <span class=o>=</span> <span class=n>SHA256</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>env_value</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;utf-8&#34;</span><span class=p>))</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span>  <span class=c1># 32 bytes =&gt; AES-256 key</span>
</span></span><span class=line><span class=cl>    <span class=n>cipher</span> <span class=o>=</span> <span class=n>AES</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>AES</span><span class=o>.</span><span class=n>MODE_CBC</span><span class=p>,</span> <span class=n>iv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>dec</span> <span class=o>=</span> <span class=n>cipher</span><span class=o>.</span><span class=n>decrypt</span><span class=p>(</span><span class=n>encrypted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># Try PKCS7 unpadding (best effort)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>dec</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>pad</span> <span class=o>=</span> <span class=n>dec</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=mi>1</span> <span class=o>&lt;=</span> <span class=n>pad</span> <span class=o>&lt;=</span> <span class=mi>16</span> <span class=ow>and</span> <span class=n>dec</span><span class=p>[</span><span class=o>-</span><span class=n>pad</span><span class=p>:]</span> <span class=o>==</span> <span class=nb>bytes</span><span class=p>([</span><span class=n>pad</span><span class=p>])</span> <span class=o>*</span> <span class=n>pad</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>dec</span> <span class=o>=</span> <span class=n>dec</span><span class=p>[:</span><span class=o>-</span><span class=n>pad</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dec</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_pe_mz</span><span class=p>(</span><span class=n>blob</span><span class=p>:</span> <span class=nb>bytes</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>bool</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>len</span><span class=p>(</span><span class=n>blob</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>2</span> <span class=ow>and</span> <span class=n>blob</span><span class=p>[:</span><span class=mi>2</span><span class=p>]</span> <span class=o>==</span> <span class=sa>b</span><span class=s2>&#34;MZ&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[1] Reading encrypted payload...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>encrypted_data</span> <span class=o>=</span> <span class=n>read_file</span><span class=p>(</span><span class=n>ENCRYPTED_FILE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    Encrypted size: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>encrypted_data</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[2] Reading IV...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>iv</span> <span class=o>=</span> <span class=n>read_file</span><span class=p>(</span><span class=n>IV_FILE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>iv</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>16</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[!] IV length is </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>iv</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes (expected 16).&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    IV: </span><span class=si>{</span><span class=n>iv</span><span class=o>.</span><span class=n>hex</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[3] Brute forcing common PROCESSOR_ARCHITECTURE values...</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>hits</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>cand</span> <span class=ow>in</span> <span class=n>CANDIDATES</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>decrypted</span> <span class=o>=</span> <span class=n>try_decrypt</span><span class=p>(</span><span class=n>cand</span><span class=p>,</span> <span class=n>encrypted_data</span><span class=p>,</span> <span class=n>iv</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>is_pe_mz</span><span class=p>(</span><span class=n>decrypted</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=n>hits</span> <span class=o>+=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=n>out_path</span> <span class=o>=</span> <span class=n>OUT_DIR</span> <span class=o>/</span> <span class=sa>f</span><span class=s2>&#34;decrypted_</span><span class=si>{</span><span class=n>cand</span><span class=si>}</span><span class=s2>.exe&#34;</span>
</span></span><span class=line><span class=cl>            <span class=n>out_path</span><span class=o>.</span><span class=n>write_bytes</span><span class=p>(</span><span class=n>decrypted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>key_hex</span> <span class=o>=</span> <span class=n>SHA256</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>cand</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s2>&#34;utf-8&#34;</span><span class=p>))</span><span class=o>.</span><span class=n>digest</span><span class=p>()</span><span class=o>.</span><span class=n>hex</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[+] HIT: </span><span class=si>{</span><span class=n>cand</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    Key(SHA-256): </span><span class=si>{</span><span class=n>key_hex</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    Saved: </span><span class=si>{</span><span class=n>out_path</span><span class=si>}</span><span class=s2> (</span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>decrypted</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes)</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1># If you only want the first valid result, uncomment this:</span>
</span></span><span class=line><span class=cl>            <span class=c1># break</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[-] </span><span class=si>{</span><span class=n>cand</span><span class=si>}</span><span class=s2>: not a PE (first bytes: </span><span class=si>{</span><span class=n>decrypted</span><span class=p>[:</span><span class=mi>8</span><span class=p>]</span><span class=o>.</span><span class=n>hex</span><span class=p>()</span><span class=si>}</span><span class=s2>)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>hits</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>[!] No valid PE hits found.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    Possible issues:&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    - The architecture value is different/unexpected&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    - IV/encrypted blob offsets are wrong&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    - Different key derivation or mode/padding&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1># Save last attempt for inspection (optional)</span>
</span></span><span class=line><span class=cl>        <span class=p>(</span><span class=n>OUT_DIR</span> <span class=o>/</span> <span class=s2>&#34;last_decrypted_raw.bin&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>write_bytes</span><span class=p>(</span><span class=n>decrypted</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    Saved last attempt to: </span><span class=si>{</span><span class=n>OUT_DIR</span> <span class=o>/</span> <span class=s1>&#39;last_decrypted_raw.bin&#39;</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>[SUCCESS] Found </span><span class=si>{</span><span class=n>hits</span><span class=si>}</span><span class=s2> valid PE candidate(s). Check: </span><span class=si>{</span><span class=n>OUT_DIR</span><span class=o>.</span><span class=n>resolve</span><span class=p>()</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>main</span><span class=p>()</span>
</span></span></code></pre></div><p><img loading=lazy src=/BTH/Day1/membase_22.png alt></p><p>Analysis of the decrypted executable was performed to understand its behavior.</p><p>The executable has two main functions:</p><ul><li>Creating a persistent user account and adding it to both the Administrators and Remote Desktop Users groups.</li><li>Decrypting an ngrok.yml file and writing a flag.txt file to the same directory.</li></ul><blockquote><p>For the purpose of this challenge, the focus was placed solely on the decryption logic, while the persistence functionality was ignored.</p></blockquote><p>Further inspection of the function sub_140004430 shows that it constructs two file paths, Src and v4, by:</p><ul><li>Using string operations to build paths under C:\Users\Public\Documents</li><li>Referencing the ngrok subdirectory</li><li>Defining ngrok.yml as the input file and flag.txt as the output file</li></ul><p><img loading=lazy src=/BTH/Day1/membase_23.png alt></p><p>This function acts as a wrapper around the main decryption routine, <code>sub_140003C50</code>. The wrapper passes two arguments to the function:</p><ul><li><code>Src</code>: the source (input) file path</li><li><code>v4</code>: the destination (output) file path</li></ul><p>A deeper look at <code>sub_140003C50</code> shows that it is the core decryption logic. It accepts two parameters:</p><ul><li><code>a1</code>: input file path (<code>Documents\ngrok\ngrok.yml</code>)</li><li><code>a2</code>: output file path (<code>Documents\ngrok\flag.txt</code>)</li></ul><p>The function reads the contents of <code>ngrok.yml</code> into memory, where the data is identified as being encrypted using <strong>AES-256-CBC</strong>.</p><p>During analysis, the address <code>&amp;unk_140032928</code> was observed being passed directly into the <code>EVP_DecryptInit_ex</code> function. This indicates:</p><ul><li>Address <code>0x140032928</code> holds the <strong>AES-256 key</strong> (32 bytes)</li><li>Variable <code>v52</code> contains the <strong>Initialization Vector (IV)</strong> (16 bytes)</li></ul><p><img loading=lazy src=/BTH/Day1/membase_24.png alt></p><p>The decryption process follows the standard OpenSSL EVP workflow:</p><ul><li><code>EVP_DecryptUpdate</code> handles the bulk of the encrypted data</li><li><code>EVP_DecryptFinal_ex</code> completes the decryption and removes <strong>PKCS#7 padding</strong></li><li><code>v27</code> stores the final decrypted plaintext</li><li><code>v29</code> holds the total size of the decrypted data</li></ul><p><img loading=lazy src=/BTH/Day1/membase_25.png alt></p><p>Once decryption completes, <code>sub_140006010</code> writes the decrypted contents from buffer <code>v27</code> (length <code>v29</code>) to the output file <code>flag.txt</code>.</p><p><img loading=lazy src=/BTH/Day1/membase_26.png alt></p><p>The IV is referenced through <code>v52</code>. By inspecting nearby XMM register loads, the IV can be recovered as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># IV may be at xmmword_140032A50 (referenced in main)</span>
</span></span><span class=line><span class=cl><span class=n>iv_addr</span> <span class=o>=</span> <span class=mh>0x140032A50</span>
</span></span><span class=line><span class=cl><span class=n>iv_data</span> <span class=o>=</span> <span class=n>ida_bytes</span><span class=o>.</span><span class=n>get_bytes</span><span class=p>(</span><span class=n>iv_addr</span><span class=p>,</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;IV (16 bytes):&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34; &#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%02X</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=n>b</span> <span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=n>iv_data</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Save IV to file</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;D:</span><span class=se>\\</span><span class=s2>BTH-Finals</span><span class=se>\\</span><span class=s2>aes_iv.bin&#34;</span><span class=p>,</span> <span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>iv_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Saved IV to aes_iv.bin&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>For</span> <span class=n>extracting</span> <span class=n>the</span> <span class=n>AES</span><span class=o>-</span><span class=mi>256</span> <span class=n>Key</span> <span class=p>(</span><span class=mi>32</span> <span class=nb>bytes</span><span class=p>):</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>```</span><span class=n>python</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>ida_bytes</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Key is at address 0x140032928</span>
</span></span><span class=line><span class=cl><span class=n>key_addr</span> <span class=o>=</span> <span class=mh>0x140032928</span>
</span></span><span class=line><span class=cl><span class=n>key_data</span> <span class=o>=</span> <span class=n>ida_bytes</span><span class=o>.</span><span class=n>get_bytes</span><span class=p>(</span><span class=n>key_addr</span><span class=p>,</span> <span class=mi>32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=&#34;</span><span class=o>*</span><span class=mi>60</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;AES-256 KEY (32 bytes):&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34; &#34;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%02X</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=n>b</span> <span class=k>for</span> <span class=n>b</span> <span class=ow>in</span> <span class=n>key_data</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;=&#34;</span><span class=o>*</span><span class=mi>60</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Save to file</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;D:</span><span class=se>\\</span><span class=s2>BTH-Finals</span><span class=se>\\</span><span class=s2>aes_key.bin&#34;</span><span class=p>,</span> <span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>key_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Saved key to aes_key.bin&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>Since <code>ngrok.yml</code> was already present on disk, the next step was simply to grab it. Using <strong>R-Studio</strong> on the memory image, I navigated to the file system and successfully recovered the file from: <code>C:\Users\Public\Documents\ngrok\ngrok.yml</code> With the encrypted config now in hand, it was ready for offline decryption and further analysis.</p><p><img loading=lazy src=/BTH/Day1/membase_27.png alt></p><p>Utilizing the following script to decrypt the ngrok.yml and get the final flag.txt:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>Crypto.Cipher</span> <span class=kn>import</span> <span class=n>AES</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>sys</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1># Step 1: Read encrypted ngrok.yml</span>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[1] Loading encrypted ngrok.yml...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;ngrok.yml&#34;</span><span class=p>,</span> <span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>encrypted_data</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    Encrypted size: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>encrypted_data</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1># Step 2: Load AES-256 key</span>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[2] Loading AES-256 key...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;aes_key.bin&#34;</span><span class=p>,</span> <span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>key</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    Key length: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>key</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1># Step 3: Load IV</span>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[3] Loading IV...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;aes_iv.bin&#34;</span><span class=p>,</span> <span class=s2>&#34;rb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>iv</span> <span class=o>=</span> <span class=n>f</span><span class=o>.</span><span class=n>read</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    IV length: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>iv</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1># Sanity checks</span>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>key</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>32</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[!] Invalid key size: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>key</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes (expected 32)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>iv</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>16</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;[!] Invalid IV size: </span><span class=si>{</span><span class=nb>len</span><span class=p>(</span><span class=n>iv</span><span class=p>)</span><span class=si>}</span><span class=s2> bytes (expected 16)&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sys</span><span class=o>.</span><span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1># Step 4: AES-256-CBC Decryption</span>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[4] Decrypting using AES-256-CBC...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>cipher</span> <span class=o>=</span> <span class=n>AES</span><span class=o>.</span><span class=n>new</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>AES</span><span class=o>.</span><span class=n>MODE_CBC</span><span class=p>,</span> <span class=n>iv</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>decrypted_data</span> <span class=o>=</span> <span class=n>cipher</span><span class=o>.</span><span class=n>decrypt</span><span class=p>(</span><span class=n>encrypted_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1># Step 5: Remove PKCS#7 padding</span>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=n>padding_len</span> <span class=o>=</span> <span class=n>decrypted_data</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=mi>1</span> <span class=o>&lt;=</span> <span class=n>padding_len</span> <span class=o>&lt;=</span> <span class=mi>16</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>decrypted_data</span> <span class=o>=</span> <span class=n>decrypted_data</span><span class=p>[:</span><span class=o>-</span><span class=n>padding_len</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;    Removed </span><span class=si>{</span><span class=n>padding_len</span><span class=si>}</span><span class=s2> bytes of PKCS#7 padding&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    Warning: Padding looks suspicious&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=c1># Step 6: Validate &amp; save output</span>
</span></span><span class=line><span class=cl><span class=c1># --------------------------------------------------</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;[5] Validating decrypted content...&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>plaintext</span> <span class=o>=</span> <span class=n>decrypted_data</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=s2>&#34;utf-8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    ✓ Valid UTF-8 text detected&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;flag.txt&#34;</span><span class=p>,</span> <span class=s2>&#34;w&#34;</span><span class=p>,</span> <span class=n>encoding</span><span class=o>=</span><span class=s2>&#34;utf-8&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>plaintext</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>[SUCCESS] flag.txt successfully decrypted!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=se>\n</span><span class=s2>Flag content:</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>plaintext</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>except</span> <span class=ne>UnicodeDecodeError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    ✗ Decrypted data is not UTF-8 text&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;flag.bin&#34;</span><span class=p>,</span> <span class=s2>&#34;wb&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>f</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>decrypted_data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;    Saved raw output to flag.bin for further analysis&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>The final flag was successfully extracted to <code>flag.txt</code>.</p><h3 id=final-flag-1>Final Flag<a hidden class=anchor aria-hidden=true href=#final-flag-1>#</a></h3><p>BHFlagY{8498302a9b7096d6ee49fc6da62496a1}</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://mmox.me/tags/bthmea/>BTHMEA</a></li><li><a href=https://mmox.me/tags/writeups/>Writeups</a></li><li><a href=https://mmox.me/tags/digital-forensics/>Digital Forensics</a></li><li><a href=https://mmox.me/tags/memory-dump/>Memory Dump</a></li><li><a href=https://mmox.me/tags/windows/>Windows</a></li><li><a href=https://mmox.me/tags/pcap/>Pcap</a></li><li><a href=https://mmox.me/tags/reverseengineering/>ReverseEngineering</a></li></ul><nav class=paginav><a class=prev href=https://mmox.me/posts/writeups/alphabox-infosecwriteup/><span class=title>« Prev</span><br><span>Alpha Box info-sec Hackathon Writeup</span>
</a><a class=next href=https://mmox.me/posts/writeups/azurepot/><span class=title>Next »</span><br><span>Cyber Defenders - AzurePot</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Black Hat Finals: Digital Forensics Challenge – Day 1 on x" href="https://x.com/intent/tweet/?text=Black%20Hat%20Finals%3a%20Digital%20Forensics%20Challenge%20%e2%80%93%20Day%201&amp;url=https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f&amp;hashtags=BTHMEA%2cWriteups%2cDigitalForensics%2cMemoryDump%2cWindows%2cPCAP%2cReverseEngineering"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Black Hat Finals: Digital Forensics Challenge – Day 1 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f&amp;title=Black%20Hat%20Finals%3a%20Digital%20Forensics%20Challenge%20%e2%80%93%20Day%201&amp;summary=Black%20Hat%20Finals%3a%20Digital%20Forensics%20Challenge%20%e2%80%93%20Day%201&amp;source=https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Black Hat Finals: Digital Forensics Challenge – Day 1 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f&title=Black%20Hat%20Finals%3a%20Digital%20Forensics%20Challenge%20%e2%80%93%20Day%201"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Black Hat Finals: Digital Forensics Challenge – Day 1 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Black Hat Finals: Digital Forensics Challenge – Day 1 on whatsapp" href="https://api.whatsapp.com/send?text=Black%20Hat%20Finals%3a%20Digital%20Forensics%20Challenge%20%e2%80%93%20Day%201%20-%20https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Black Hat Finals: Digital Forensics Challenge – Day 1 on telegram" href="https://telegram.me/share/url?text=Black%20Hat%20Finals%3a%20Digital%20Forensics%20Challenge%20%e2%80%93%20Day%201&amp;url=https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Black Hat Finals: Digital Forensics Challenge – Day 1 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Black%20Hat%20Finals%3a%20Digital%20Forensics%20Challenge%20%e2%80%93%20Day%201&u=https%3a%2f%2fmmox.me%2fposts%2fblackhatema-forensics%2fday1%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><html></html></article></main><footer class=footer><span>&copy; 2025 <a href=https://mmox.me/>MMOX Blog</a></span>
<span>- Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer">Hugo</a> &
        <a href=https://github.com/Wonderfall/hugo-WonderMod/ rel=noopener>WonderMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script defer crossorigin=anonymous src=/assets/js/papermod.7ea300eda6d3653624a576fbc095ccd8a0c2977756acbe5de4114132a72cc7fa.js integrity="sha256-fqMA7abTZTYkpXb7wJXM2KDCl3dWrL5d5BFBMqcsx/o="></script></body></html>